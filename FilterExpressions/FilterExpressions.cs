using System;

namespace FilterExpressions
{



    public static class LinqExtensions
    {
        public static FilterSetting GetFilterSetting<T>(Expression<Func<T, object>> exp, FilterOperator? defaultOperator = null)
        {
            var expStr = exp.Body.ToString().Replace("Convert(", "").Replace(", Object)", "");
            var x = Expression.Parameter(typeof(T), "x");
            var properties = expStr.Split('.');
            var property = Expression.Property(x, properties[1]);
            for (var i = 2; i < properties.Length; i++)
            {
                property = Expression.Property(property, properties[i]);
            }
            var fs = new FilterSetting(property, x)
            {
                ModelName = typeof(T).Name,
                DefaultOperator = defaultOperator
            };
            return fs;
        }
        public static string[] GetPropertiesAsString<T>()
        {
            IList<PropertyInfo> props = new List<PropertyInfo>(typeof(T).GetProperties());
            return props.Select(prop => prop.Name).ToArray();
        }

        public static IQueryable<T> Filter<T>(this IQueryable<T> queryset, ListRequest dto) where T : class
        {
            var filterExp = dto.ParsedFilterExp;
            var modelName = (typeof(T)).Name;
            if (string.IsNullOrEmpty(filterExp))
            {
                //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
                if (dto.FilterSettings == null)
                {
                    return queryset;
                }
                //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
                //var isFilterAutoGenerated = false;
                filterExp = dto.FilterExps != null ? (dto.FilterExps.ContainsKey(modelName) ? dto.FilterExps[modelName] : null) : null;
                if (dto.Filters != null && string.IsNullOrEmpty(filterExp))
                {
                    filterExp = BuildFilterExp(dto);
                    //isFilterAutoGenerated = true;
                }
                //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
                if (string.IsNullOrEmpty(filterExp))
                {
                    filterExp = dto.FilterExp;
                    modelName = null;
                }
                //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
                if (string.IsNullOrEmpty(filterExp))
                {
                    return queryset;
                }
                dto.FieldFilters = ParseFilterExp(ref filterExp, dto);
            }
            //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
            //filterExp = HttpUtility.UrlDecode(filterExp);

            if (dto.FieldFilters.Count > 0)
            {
                //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
                int endIndex;
                var cond = ParseExpStrRecursive<T>(dto, modelName, 0, filterExp, 0, out endIndex);
                if (cond != null)
                {
                    queryset = queryset.Where(cond);
                }
            }
            //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
            return queryset;
        }

        public static bool ParseFilterExp(ListRequest dto, string customFilterExp)
        {
            dto.FilterExp = customFilterExp;
            dto.FieldFilters = ParseFilterExp(ref customFilterExp, dto);
            dto.ParsedFilterExp = customFilterExp;
            return dto.FieldFilters.Count > 0;
        }


        public static string BuildFilterExp(ListRequest dto)
        {
            string filterExp = "";
            var expGroups = new List<string>();
            foreach (var fieldName in dto.Filters.Keys)
            {
                if (!dto.FilterSettings.ContainsKey(fieldName) || !dto.FilterSettings[fieldName].IsAllowFilter)
                {
                    throw new ErrorException(400, "fieldIsNotAllowedToFilter", fieldName);
                }
                var fieldSetting = dto.FilterSettings[fieldName];
                var values = dto.Filters[fieldName];
                var expInnerGroups = new List<string>();
                foreach (var value_ in values)
                {
                    var value = value_?.Trim();
                    if (!string.IsNullOrEmpty(value))
                    {
                        expInnerGroups.Add($"({fieldName} {fieldSetting.DefaultOperator} `{value}`)");
                    }
                }
                expGroups.Add("(" + string.Join(" or ", expInnerGroups) + ")");
            }
            filterExp = string.Join(" and ", expGroups);
            return filterExp;
        }

        /// <summary>
        /// Gt|Lt|Eq|Le|Ge|Ne|Contains|StartsWith|EndsWith|In
        /// ref: Lib.Enum.FilterOperator
        /// ref: LinqExtensions.CreateFilter
        /// </summary>
        private static readonly string _regexGetFilterGroupDetails =
            @"(not)?\([ ]*([a-z0-9_\.\-]+)[ ]+(Gt|Lt|Eq|Le|Ge|Ne|Contains|StartsWith|EndsWith|In)[ ]*`([^`]*)`[ ]*([a-z]*)[ ]*\)";

        private static readonly Dictionary<string, FieldFilterMethod> _FieldFilterMethods = new Dictionary<string, FieldFilterMethod>
        {
            ["List<int>"] = new FieldFilterMethod
            {
                ValueType = typeof(List<int>),
                Method = typeof(List<int>).GetMethod(nameof(List<int>.Contains), new[] { typeof(int) })
            },
            ["List<int?>"] = new FieldFilterMethod
            {
                ValueType = typeof(List<int?>),
                Method = typeof(List<int?>).GetMethod(nameof(List<int?>.Contains), new[] { typeof(int?) })
            },
            ["List<string>"] = new FieldFilterMethod
            {
                ValueType = typeof(List<string>),
                Method = typeof(List<string>).GetMethod(nameof(List<string>.Contains), new[] { typeof(string) })
            },
            ["Contains"] = new FieldFilterMethod
            {
                ValueType = typeof(string),
                Method = typeof(string).GetMethod(nameof(string.Contains), new[] { typeof(string) })
            },
            ["StartsWith"] = new FieldFilterMethod
            {
                ValueType = typeof(string),
                Method = typeof(string).GetMethod(nameof(string.StartsWith), new[] { typeof(string) })
            },
            ["EndsWith"] = new FieldFilterMethod
            {
                ValueType = typeof(string),
                Method = typeof(string).GetMethod(nameof(string.EndsWith), new[] { typeof(string) })
            },
            ["iContains"] = new FieldFilterMethod
            {
                ValueType = typeof(string),
                Method = typeof(MiscExtensions).GetMethod(nameof(MiscExtensions.ContainsIgnoreCase),
                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null,
                    new[] { typeof(string), typeof(string) }, null)
            },
            ["iStartsWith"] = new FieldFilterMethod
            {
                ValueType = typeof(string),
                Method = typeof(MiscExtensions).GetMethod(nameof(MiscExtensions.StartsWithIgnoreCase),
                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null,
                    new[] { typeof(string), typeof(string) }, null)
            },
            ["iEndsWith"] = new FieldFilterMethod
            {
                ValueType = typeof(string),
                Method = typeof(MiscExtensions).GetMethod(nameof(MiscExtensions.EndsWithIgnoreCase),
                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null,
                    new[] { typeof(string), typeof(string) }, null)
            }
        };

        public static Dictionary<string, FieldFilter> ParseFilterExp(ref string filterExp, ListRequest dto)
        {
            var groups = Regex.Matches(filterExp, _regexGetFilterGroupDetails, RegexOptions.IgnoreCase);
            var fieldFilters = new Dictionary<string, FieldFilter>();
            for (var i = 0; i < groups.Count; i++)
            {
                //Log.Debug($@"A - {DateTime.Now.ToString("O")}");
                var g = groups[i];
                var groupName = $"group{i}";
                var not = g.Groups[1]?.Value == "not";
                var fieldName = g.Groups[2].Value;
                filterExp = filterExp.Replace(g.ToString(), $"({groupName})");
                var value = g.Groups[4]?.Value?.Trim();
                if (value == null) continue;

                FilterOperator? operator_ = g.Groups[3].Value.ToEnum<FilterOperator>();

                // No need this anymore, cause auto gen exp already included default operator
                //if ((isFilterAutoGenerated || operator_ == null)
                //    && dto.FilterSettings != null
                //    && dto.FilterSettings.ContainsKey(fieldName))
                //{
                //    operator_ = dto.FilterSettings[fieldName].DefaultOperator;
                //}
                fieldFilters[groupName] = new FieldFilter
                {
                    Not = not,
                    Exp = g.Groups[0]?.Value,
                    FieldName = fieldName,
                    Operator = operator_.Value,
                    Value = value,
                    ValueTypeString = g.Groups[5]?.Value
                };
            }
            return fieldFilters;
        }

        private static Expression<Func<T, bool>> ParseExpStrRecursive<T>(ListRequest dto, string modelName, int level,
            string filterExp, int startIndex, out int endIndex) where T : class
        {
            Expression<Func<T, bool>> current = null;
            string strExp = null;
            var i = startIndex;
            var startLevel = level;
            bool? isAnd_;
            while (i <= filterExp.Length - 1)
            {
                if (filterExp[i] == '(')
                {
                    strExp = filterExp.Substring(startIndex, i - startIndex);
                    isAnd_ = null;
                    var tmp1 = ParseExpStr<T>(dto, modelName, strExp, out isAnd_);
                    if (tmp1 != null)
                    {
                        current = tmp1;
                    }
                    var tmp = ParseExpStrRecursive<T>(dto, modelName, level + 1, filterExp, i + 1, out endIndex);
                    if (isAnd_ != null && current != null && tmp != null)
                    {
                        if (isAnd_.Value)
                        {
                            current = current.And(tmp);
                        }
                        else if (!isAnd_.Value)
                        {
                            current = current.Or(tmp);
                        }
                    }
                    else if (tmp != null && current == null)
                    {
                        current = tmp;
                    }

                    i = endIndex;
                    startIndex = endIndex;
                }
                else if (filterExp[i] == ')')
                {
                    strExp = filterExp.Substring(startIndex, i - startIndex);
                    isAnd_ = null;
                    var tmp = ParseExpStr<T>(dto, modelName, strExp, out isAnd_);
                    if (isAnd_ != null && current != null && tmp != null)
                    {
                        if (isAnd_.Value)
                        {
                            current = current.And(tmp);
                        }
                        else if (!isAnd_.Value)
                        {
                            current = current.Or(tmp);
                        }
                    }
                    else if (tmp != null && current == null)
                    {
                        current = tmp;
                    }
                    i++;
                    startLevel -= 1;
                    if (startLevel < level)
                    {
                        break;
                    }
                }
                else
                {
                    i++;
                }
            }
            endIndex = i;
            return current;
        }

        private static Expression<Func<T, bool>> ParseExpStr<T>(ListRequest dto, string modelName,
            string strExp, out bool? isAnd) where T : class
        {
            Expression<Func<T, bool>> current = null;
            bool? isAnd_ = null;
            if (!string.IsNullOrEmpty(strExp))
            {
                var strExps = strExp.Trim().Split(' ');
                foreach (var expItem_ in strExps)
                {
                    var expItem = expItem_.Trim();
                    if (expItem == string.Empty) continue;
                    if (expItem == "or")
                    {
                        isAnd_ = false;
                    }
                    else if (expItem == "and")
                    {
                        isAnd_ = true;
                    }
                    else if (dto.FieldFilters.ContainsKey(expItem))
                    {
                        var field = dto.FieldFilters[expItem];
                        var valueType = field.ValueType;
                        try
                        {
                            if (!dto.FilterSettings.ContainsKey(field.FieldName)
                                || !dto.FilterSettings[field.FieldName].IsAllowFilter)
                            {
                                throw new Exception("Field is not allowed.");
                            }
                            var fieldSetting = dto.FilterSettings[field.FieldName];
                            if (modelName != null && fieldSetting.ModelName != modelName)
                            {
                                continue;
                            }
                            if (valueType == null)
                            {
                                valueType = dto.FilterSettings[field.FieldName].ValueType;
                            }
                            if (current == null)
                            {
                                current = CreateFilter<T>(fieldSetting, field, ref valueType, dto.ToSql);
                            }
                            else if (isAnd_.Value)
                            {
                                current = current.And(CreateFilter<T>(fieldSetting, field, ref valueType, dto.ToSql));
                            }
                            else if (current != null && !isAnd_.Value)
                            {
                                current = current.Or(CreateFilter<T>(fieldSetting, field, ref valueType, dto.ToSql));
                            }
                        }
                        catch (Exception ex)
                        {
                            var details = new List<string>();
                            details.Add($"Expression: {field.Exp}");
                            details.Add($"Field: {field.FieldName}");
                            details.Add($"Operator: {field.Operator.ToString()}");
                            details.Add($"Value: {field.Value}");
                            details.Add($"ValueType: {valueType?.Name}");
                            throw new ErrorException(400, ex.Message, details);
                        }
                    }
                }
            }
            isAnd = isAnd_;
            return current;
        }

        public static Expression<Func<T, bool>> CreateFilter<T>(FilterSetting filterSetting, FieldFilter field, ref Type valueType, bool toSql = true) where T : class
        {
            var propertyName = filterSetting.FieldName;
            var property = filterSetting.Field();
            var parameter = filterSetting.Parameter();
            Type type = typeof(T);
            if (property == null)
            {
                parameter = Expression.Parameter(type, "x");
                var properties = propertyName.Split('.');
                property = Expression.Property(parameter, properties[0]);
                for (var i = 1; i < properties.Length; i++)
                {
                    property = Expression.Property(property, properties[i]);
                }
            }
            Expression q = null;
            FieldFilterMethod m = null;
            if (valueType == null)
            {
                valueType = property.Type;
            }
            if (field.Operator == FilterOperator.In)
            {
                if (valueType == typeof(int))
                {
                    m = _FieldFilterMethods["List<int>"];
                    q = Expression.Call(Expression.Constant(field.Value.GetIntList(0), m.ValueType),
                        m.Method ?? throw new InvalidOperationException(), property);
                }
                else if (valueType == typeof(int?))
                {
                    m = _FieldFilterMethods["List<int?>"];
                    q = Expression.Call(Expression.Constant(field.Value.GetNullableIntList(), m.ValueType),
                        m.Method ?? throw new InvalidOperationException(), property);
                }
                else if (valueType == typeof(string))
                {
                    m = _FieldFilterMethods["List<string>"];
                    q = Expression.Call(Expression.Constant(field.Value.Split(',').ToList(), m.ValueType),
                        m.Method ?? throw new InvalidOperationException(), property);
                }
            }
            else
            {
                var parsedValue = _ParseValue(filterSetting, field.Value, valueType);
                switch (field.Operator)
                {
                    case FilterOperator.Gt:
                        q = Expression.GreaterThan(property, Expression.Constant(parsedValue, valueType));
                        break;
                    case FilterOperator.Lt:
                        q = Expression.LessThan(property, Expression.Constant(parsedValue, valueType));
                        break;
                    case FilterOperator.Eq:
                        q = Expression.Equal(property, Expression.Constant(parsedValue, valueType));
                        break;
                    case FilterOperator.Le:
                        q = Expression.LessThanOrEqual(property, Expression.Constant(parsedValue, valueType));
                        break;
                    case FilterOperator.Ge:
                        q = Expression.GreaterThanOrEqual(property, Expression.Constant(parsedValue, valueType));
                        break;
                    case FilterOperator.Ne:
                        q = Expression.NotEqual(property, Expression.Constant(parsedValue, valueType));
                        break;
                    case FilterOperator.Contains:
                        if (toSql)
                        {
                            m = _FieldFilterMethods["Contains"];
                            q = Expression.Call(property, m.Method ?? throw new InvalidOperationException(),
                                Expression.Constant(parsedValue, m.ValueType));
                        }
                        else
                        {
                            m = _FieldFilterMethods["iContains"];
                            q = Expression.Call(m.Method ?? throw new InvalidOperationException(), property,
                                Expression.Constant(parsedValue, m.ValueType));
                        }
                        break;
                    case FilterOperator.StartsWith:
                        if (toSql)
                        {
                            m = _FieldFilterMethods["StartsWith"];
                            q = Expression.Call(property, m.Method ?? throw new InvalidOperationException(),
                                Expression.Constant(parsedValue, m.ValueType));
                        }
                        else
                        {
                            m = _FieldFilterMethods["iStartsWith"];
                            q = Expression.Call(m.Method ?? throw new InvalidOperationException(), property,
                                Expression.Constant(parsedValue, m.ValueType));
                        }
                        break;
                    case FilterOperator.EndsWith:
                        if (toSql)
                        {
                            m = _FieldFilterMethods["EndsWith"];
                            q = Expression.Call(property, m.Method ?? throw new InvalidOperationException(),
                                Expression.Constant(parsedValue, m.ValueType));
                        }
                        else
                        {
                            m = _FieldFilterMethods["iEndsWith"];
                            q = Expression.Call(m.Method ?? throw new InvalidOperationException(), property,
                                Expression.Constant(parsedValue, m.ValueType));
                        }
                        break;
                }
            }

            if (q == null)
            {
                throw new Exception($"Filter operator `{field.Operator}` with type `{valueType}` is not supported yet.");
            }

            if (field.Not)
            {
                return Expression.Lambda<Func<T, bool>>(Expression.Not(q), parameter);
            }
            else
            {
                return Expression.Lambda<Func<T, bool>>(q, parameter);
            }
        }

        private static object _ParseValue(FilterSetting filterSetting, string value, Type type)
        {
            var v = value.Trim();

            if (type == typeof(string)) return v;

            if (type == typeof(DateTime)) return DateTime.Parse(v);
            if (type == typeof(DateTime?)) return v.ParseNullableDateTime();

            if (type == typeof(int)) return int.Parse(v);
            if (type == typeof(int?)) return v.ParseNullableInt();

            if (type == typeof(decimal)) return decimal.Parse(v);
            if (type == typeof(decimal?)) return v.ParseNullableDecimal();

            if (type == typeof(bool)) return filterSetting.IsNot ? !bool.Parse(v) : bool.Parse(v);
            if (type == typeof(bool?)) return filterSetting.IsNot ? !v.ParseNullableBool() : v.ParseNullableBool();

            throw new Exception($"Convert value `{value}` to type `{type}` is not supported yet.");
        }
    }
    public class FieldFilterMethod
    {
        public Type ValueType { get; set; }
        public MethodInfo Method { get; set; }
    }
}